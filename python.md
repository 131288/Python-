# python

## 第一个python程序

``` python
print ("Hellow world!")
print("你好世界！")
```

**全部内容由英文来写，print引号里面的内容随意。**

### Python解释器

1. 翻译代码。
2. 提交给计算机运行。

可用记事本将所需要的代码以.py结尾文件保存再用CMD开启。

```python 
python  输入需要翻译文件路径之后回车即可
```

### 开发环境

使用最多的开发工具为PyCharm.

[相关链接](http://www.jetbrains.com)

*<u>此链接为PyCharm的下载链接。</u>*

[安装视频链接](https://www.bilibili.com/video/BV1qW4y1a7fU?p=11&spm_id_from=pageDriver&vd_source=efccf40b3077196051f3e7f3d26fffb1&t=339.9)

### PyCharm的基础使用

[使用链接](https://www.bilibili.com/video/BV1qW4y1a7fU?p=12&spm_id_from=pageDriver&vd_source=efccf40b3077196051f3e7f3d26fffb1&t=13.7)

文件.py为记录python的文件包含了python语言。

## 语法

### 字面量

即在代码中，被写下来的固定的值，称之为字面量。

| 类型             | 程序中的写法 | 说明                                         |
| ---------------- | ------------ | -------------------------------------------- |
| 1.整数           | 666，248     | 和现实中的写法一致。                         |
| 2.浮点数（小数） | 12.2，12.6   | 和现实中的写法一致。                         |
| 3.字符串（文本） | "你好"       | 程序中需要加上双引号来表示字符串（用英语）。 |

```python 
666   输出字符串：666
12.5  输出字符串：12.5
"你好"  输出字符串：你好
```

### 注释

即，在代码中对程序代码进行解释说明的文字。

作用：注释不是程序，不能被执行，只是对程序代码进行解释说明，让别人可以看懂程序代码的作用，能够增强程序的可读性。

* 单行注释：以==#====开头==，==#右边==  的所有文字当作说明，而不是真正要执行的程序，起辅助说明作用。

```python
#单行注释
print ("Hellow world")
```

==注意，#号和注释内容一般建议以一个空格隔开（规范要求）。==

多行注释：==以 一对三个引号==  引起来(==“”“注释内容”“”==)来说明一段代码的使用方法。

```py
"""
学号代码
挣大钱
早日娶媳妇
"""
print("你们好！")

```

注释是代码中的解释性语句，用来对代码内容进行注解。

注释不是代码，不会被程序执行。

### 变量

即==在程序运行时==，能==储存==计算结果或==表示值==的抽象概念。简单地说，变量就是在程序运行时记录数据用的。

变量的定义格式：变量名称=变量的值

变量名称：每一个变量都有自己的名称，称之为变量名，也就是变量本身。

=：赋值，表示将等号右侧的值，赋予左侧的变量。

变量的值：：每一个变量都有自己储存的值（内容），称之为变量值。

当需要输出多份语句时:

```python
print(内容1，内容2，内容3,...,内容n)
```

### 数据类型

| 类型   | 描述             | 说明                                 |
| ------ | ---------------- | ------------------------------------ |
| string | 字符串类型       | 用引号引起来的数据都是字符串。       |
| int    | 整数(有符号)     | 数字类型，存放整数 如 2，4，6，8等。 |
| fioat  | 浮点型（有符号） | 数字类型，存放小数 如 3.14，6.66等。 |

可以通过typr()语句（会给出结果）来得到的类型：string，int，fioat。

方法：

```py
#使用print直接输出类型信息
print(type("你好"))
print(type(243))
print(type(10.3))
```

```py
#使用变量存储type()语句的结果
string_type=type("你好")
int_type=type(243)
float_tyoe=type(22.35)
print(string_type)
print(int_type)
print(float_tyoe)

```

```py
#使用type()语句，查看变量中存储的数据类型信息
price=20
price_type=type(price)
print(price_type)
```

查看变量的类型是数据的类型，即是，变量存储的数据的类型。因为变量无类型但是它存储的数据有。

变量没有类型，字符串变量表示变量存储了字符串而不是表示变量就是字符串。

### 数据类型转换

数据类型之间在特定的场景下是可以相互转换的，如字符串转数字，数字转字符串等。

| 数据类型转换，将会是我们以后经常使用的功能：                 |
| ------------------------------------------------------------ |
| 1. 从文件中读取的数字，默认是字符串，我们需要转换成数字类型。 |
| 2. 后续学习的input()语句默认结果是字符串，若需要数字也需要转换。 |
| 3.将数字转换成字符串用以写出到外部系统。                     |
| 4. 等等。                                                    |

常见的转换语句：

| 语句（函数） | 说明                |
| ------------ | ------------------- |
| int(x)       | 将X转换为一个整数   |
| float(x)     | 将x转换为一个浮点数 |
| str(x)       | 将对象x转换为字符串 |

想要将字符串转换成数字，必须要求字符串内容的内容都是数字。

### 标识符

即用户在编程的时候所使用的一系列名字，用于给变量，类，方法等命名。

python中，标识符命名的规则主要有三类：

1. 类容限定。
2. 大小写敏感。
3. 不可使用关键字。

标识符命名中只允许出现：

1. 英文（大小写是完全能够区分的）
2. 中文（不大推介）
3. 数字（不可以用在开头）
4. 下划线（__）

这四类元素。其余任何内容都不被允许。

标识符的命名的规范：

不同的标识符有不同的规范。

1. 见名知意：明了即尽量做到看见名字就知道是什么意思了；简洁即尽量在确保明了的前提下减少名字的长度；
2. 下划线命名法：多个单词组合变量名，要使用下划线做分隔。
3. 英文字母全小写：命名变量中的英文字母应全部小写。

### 运算符

| 运算符 | 描述   | 实例                                                   |
| ------ | ------ | ------------------------------------------------------ |
| +      | 加     | 两个对象相加a+b输出结果为c                             |
| -      | 减     | 得到负数或是一个数减去另一个数a-b输出结果为c           |
| *      | 乘     | 两个数相乘或是返回一个被重复若干次的字符串a*b输出结果c |
| /      | 除     | b/a输出结果c                                           |
| //     | 取整数 | 返回商的整数部分9//2输出结果为四，9.0//2.0输出结果4.0  |
| %      | 取余   | 返回除法的余数b%a输出结果为c                           |
| **     | 指数   | a**b为10的20次方，输出结果100000000000000000000        |

#### 赋值运算符

| 运算符 | 描述       | 实例                                                      |
| ------ | ---------- | --------------------------------------------------------- |
| =      | 赋值运算符 | 把=号右边的结果赋给左边的变量，如num=1+2*3,结果num的值为7 |

#### 复合赋值运算

| 运算符 | 描述             | 实例                 |
| ------ | ---------------- | -------------------- |
| +=     | 加法赋值运算符   | c+=a等效于c=c+a      |
| -=     | 减法赋值运算符   | c-=a等效于c=c-a      |
| *=     | 乘法赋值运算符   | c*=a等效于c *a       |
| /=     | 除法赋值运算符   | c/=a等效于c/a        |
| %=     | 取模赋值运算符   | c%=a等效于c%a        |
| **=    | 幂赋值运算符     | c** =a等效于  c  **a |
| //=    | 取整数赋值运算符 | c//=a等效于c//a      |

### 字符串拓展

字符串的三种定义

* 字符串在Python中有多种定义形式：

1. 单引号定义法可以内含双引号
2. 双引号定义法可以内含单引号
3. 三引号定义法

```python
name='你好'
name="你好"
你好="""你好"""
```

三引号定义法，和多行注释写法一样，同样支持换行操作。

使用变量接收它，它就是字符串，当不能用变量接收它，就可以作为多行注释使用。

| 列表append(元素)        | 向列表中追加一个元素                         |
| ----------------------- | -------------------------------------------- |
| 列表extend(容器)        | 将数据容器的内容依次取出，追加到列表尾部     |
| 列表.insert(下标，元素) | 在指定下标处，插入指定的元素                 |
| del列表[下标]           | 删除列表指定下标元素                         |
| 列表.pop(下标)          | 删除列表指定下标元素                         |
| 列表.remove(元素)       | 从前向后，删除此元素第一个匹配项             |
| 列表clear()             | 清空列表                                     |
| 列表.count(元素)        | 统计此元索在列表中出现的次数                 |
| 列表index(元素)         | 查找指定元素在列表的下标找不到报错ValueError |
| len(列表)               | 统计容器内有多少元本                         |

当想要定义的字符串本身是包含引号时：

可以使用转移字符（\）来将引号解除效用，变成普通字符串。也可用上述所说方法解决。

```py
name='"你好"'
name="'你好'"
name="\"你好\""
name='\'你好\''
```

### 字符串拼接

如果有两个字符串（文本）字面量，可以将其拼成一个字符串，通过+号即可完成，

```python 
print("你好"+"世界")
```

不过一般单纯的2个字符串字面量进行拼接显得很呆，所以，字面量和变量或变量之间会使用拼接，如

```python
name="你好"
print=(name+"你好")
```

注意：该方式不能与数字以及浮点数等使用。即无法和非字符串类型进行拼接。

### 字符串格式化

可以使用如下方式：

```python
name="你好"
message="世界 %s" % name
print=(message)
```

注意：其中%s

* %表示：我要占位。

* s表示：将变量变成字符串放入占位的地方。

  所以，综合起来的意思就是：我先占个位置，等会有一个变量过来，我把它变成字符串放到占位的位置。

  ```python
  class_num=57
  avg_salary=18762
  message="你的工资为%s元，工作时长为%s小时"%(ciass_num,avg_salary)
  print(message)
  ```

  

Python中最常用的数据类型占位：

| 格式符号 | 转化                               |
| -------- | ---------------------------------- |
| %s       | 将内容转换成字符串，放入占位位置。 |
| %d       | 将内容转换成整数，放入占位位置。   |
| %f       | 将内容转换成浮点型，放入占位位置。 |

字符串格式化的语法：

```python
"%占位符"%变量
```

### 格式化的精度控制

#### 字符串格式化—数字精度控制

我们可以使用辅助符号"m，n"来控制数据的宽度和精度。

* m：控制宽度，要求是数字(很少使用)，设置宽度小于数字自身，不生效。
* .n：控制小数点精度，要求是数字，会进行小数的四舍五入。

例：%5d:表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成

```python [空格][空格]
[空格][空格][空格]11
```

即用三个空格补足宽度。

%5.2f：表示将宽度控制为5，将小数点精度设置为2.

小数点和小数部分也算入宽度计算。如：对11.342设置了%5.2f后，结果是

```python 
[空格][空格]11.34
```

两个空格补足宽度，小数部分限制两位精度后，四舍五入为.35.

%2f：表示不限制宽度，只设置小数点精度为2，如11.345设置%2f后结果是11.35.

==注意==：在使用精度控制的语法时m .n可以省略

### 字符串格式化方式2

可通过语法：

```python 
f"内容{变量}"
```

来快速格式化。

这种方式的特点：

1. 不理会类型。
2. 不做精度控制。

适合对精度没有要求的时候快速使用。

### 对表达式进行格式化

#### 字符串格式化—表达式的格式话

```python 
print("1*1的结果是:%d"%(1*1))
print(f"1*1的结果是：{1*1}")
print("字符串在python里的类型是：%s"%type('字符串'))
```

在无需使用变量进行数据存储的时候，可以直接格式化表达式，简化代码。

* f"{表达式}"
* “%s\%d\%f”(表达式，表达式，表达式)

## 数据输入

### input语句(函数)

* 数据输出：print
* 数据输入：input (可以从键盘获取输入，然后使用一个变量接收input语句获取的键盘输入数据即可)

如果需要使用数字时需要自行转换。

注意：无论键盘输入什么类型的数据，获得的数据永远都是字符串类型。

可以使用：input(提示信息)，用以在使用者输入内容

## Python判断语句

### 布尔类型和比较运算符

1. 掌握布尔类型用于表示：真和假。进行判断只有两个结果：是与否。
2. 掌握比较运算符用于计算：真假。

| 类型               | 表述                                                  | 说明                                                         |
| ------------------ | ----------------------------------------------------- | ------------------------------------------------------------ |
| 数字（Number）     | 支持整数(int),浮点数(fioat),复数（complex）布尔(bool) | 整数如：1，10，20；浮点数如：13.2，10.6；复数如：4+3j，以j结尾表示复数；布尔表达现实生活中的逻辑，即真和假，True表示真，False表示假。True本质上是一个数字记作1，False记作0. |
| 字符串（String）   | 表述文本的一种数据类型                                | 字符串由任意数量的字符组成。                                 |
| 列表(List)         | 有序的可变序列                                        | Python中使用最频繁的数据类型，可有序记录数据一堆数据。       |
| 元组（Tuple）      | 有序的不可变序                                        | 可有序记录一堆不可变的Python数据集合。                       |
| 集合（Set）        | 无序不重复集合                                        | 可无序记录一堆不可变的Python数据集合。                       |
| 字典（Dictionary） | 无须Key-Value                                         | 可无序记录一堆Key-Value型的Python数据集合。                  |

布尔类型的字面量：

* True表示真(是，肯定)
* False表示(否，否定)

定义变量存储布尔类型数据：

```python 
变量名称=布尔类型字面量
```

布尔类型不仅可以自行定义同时也可以通过计算得来。也就是使用比较运算符进行运算得到布尔类型的结果。

| 运算符 | 描述                                                       | 示例                      |
| ------ | ---------------------------------------------------------- | ------------------------- |
| ==     | 判断内容是否相等，满足为真，不满足为假。                   | 如：a=3 b=3(a==b)为真     |
| ！=    | 判断内容是否不相等，满足为真，不满足为假。                 | 如：a=3 b=1(a!=b)为真     |
| >      | 判断左侧运算符内容是否大于右侧，满足为真，不满足为假。     | 如：如：a=3 b=1(a>b)为真  |
| <      | 判断运算符左侧内容是否小于右侧，满足为真，不满足为假。     | 如：a=4 b=7(a<b)为真      |
| >=     | 判断运算符左侧内容是否大于等于右侧，满足为真，不满足为假。 | 如：如：a=3 b=3(a>=b)为真 |
| <=     | 判断运算符左侧内容是否小于等于右侧，满足为真，不满足为假。 | 如：如：a=3 b=3(a<=b)为真 |

注意：在书写时要注意大小写。

### if语句的基本格式

```py
if要判断的条件：
条件成立时，要做的事情。
```



```python
#定义变量
age=30
#进行判断
if age>=18：
    print("我已经成年了。")
```

print之前需要四个空格。如果没有空格将不受if条件的限制会与if同级，Python通过缩进判断代码的归属关系。

注意：判断语句的结果必须是布尔类型True或False，True会执行if内的代码语句False则不会。不要忘记判断条件后的冒号，归属于if语句的代码块需在前方填充4个空格缩进。

### if else语句

if条件：

满足条件时要做的事情1

满足条件时要做的事情2

满足条件时要做的事情3

满足条件时要做的事情4......

else条件：

不满足条件时要做的事情1

不满足条件时要做的事情2

不满足条件时要做的事情3

不满足条件时要做的事情4......

```python
age=input("您的年龄：")
if int(age) >=18:
  print(f"您已成年，游玩需要补票10元。")
else:
    print("您未成年，可以免费游玩。")
print("祝您游玩愉快！")
```

注意：else，不需要判断条件，和if的代码块一样，需要4个空格作为缩进。

### if elif else

if条件1：

​    条件1满足应做的事情

​    条件1满足应做的事情......

elif条件2：

​    条件2满足应做的事情

​    条件2满足应做的事情......

elif条件3：

​    条件3满足应做的事情

​    条件3满足应做的事情......

else:

​    所有条件不满足应做的事情

​    所有条件不满足应做的事情......

注意：elif与if也是同级的。当满足其中一个条件后后面的条件将不会再编译。

```py
print("欢迎来到动物园！")
vip_level=int(input("请输入你的vip等级（1~5）："))
high =int(input("请输入你的身高(cm)："))
if  high<120.0:
    print("您的身高小于120cm，可以免费游玩。")
elif vip_level>3:
    print ("您的vip等级大于3，可以免费游玩。")
else:
  print ("不好意思，您不满足所有条件，需要购票10元。")
print ("祝您游玩愉快！")
```

注意：判断时互斥且有序的。

* 当满足条件1将不会理会2和3
* 满足2，将不会理会3
* 1，2，3均不满足，进入else
* else也可以省略不写，效果等同3个独立的if判断。
* 可以在条件判断中，直接写input语句，节省代码量

```python
num=10
if int(input("请输入第一次猜想的数字：")) ==num:
    print("恭喜你答对了！")
elif int(input("猜错了，再猜一次：")) ==num:
    print("猜对了！恭喜你")
elif int(input("猜错了，再猜一次：")) ==num:
    input("不对，再猜最后一次：")
    print("恭喜你猜对了！")
else:
    print ("Sorry,全部猜错了，我想的是：10！")
print ("感谢您的参与！")
```

### 判断语句的嵌套

许多逻辑的判断是嵌套的，多层的，对于这种需求我们可以自由组合：if  elif  else,完成特定需求的要求。

基础语法格式：

if条件1：

​    满足条件1做的事情1

​    满足条件1做的事情2

​    if条件2：

​        满足条件2做的事情1

​        满足条件2做的事情2

第二个if属于第一个if内，当只有满足第一个if的条件时，才会执行第二个if。

嵌套的关键点在于空格缩进，通过空格缩进来决定语句之间的层次关系。

同等缩进为同等级别可相互使用。

```python
import random
num=random.randint(1,10)
num2=int(input("请输入你的第一次猜想："))
if num==num2:
    print("恭喜你猜对了")
else:
    if num<num2:
        print("你的猜想大了。")
    else:
        if num>num2:
            print("你的猜想小了。")
    num2 = int(input("请再次输入你第二次的猜想："))
    if num==num2:
        print("恭喜你猜对了。")
    else:
        if num<num2:
            print("你的猜想大了。")
        else:
            if num>num2:
                print("你的猜想小了。")
        num2 = int(input("请再次输入你的第三次猜想："))
        if num==num2:
            print("恭喜你猜对了。")
        else:
            print("三次机会用完了，没有猜中！")
```

## Python循环语句

### while循环的基础语法

程序中的循环

while条件：

​    条件满足时，做的事情1

​    条件满足时，做的事情2

​    条件满足时，做的事情3

​    ......

只要条件满足就会无限循环执行。

```python
i=0
while i<100:
    print("你好！")
    i+=1
```

1. while的条件需得到布尔类型，True表示继续循环，False表示循环结束。
2. 需要设置循环终止的条件，如：i+=1配合i<100，就能保证100次后停止，否则将无限循环。
3. 空格缩进和if判断，都需要设置。

### while循环猜数字案例

```python
import random
num=random.randint(1,100)
count=0
flag=True
while flag:
    guess_num=int(input("请输入你猜测的数字："))
    count+=1
    if guess_num==num:
        print("恭喜你猜对了！")
        flag=False
    else:
        if guess_num>num:
            print("你猜大了。")
        else:
            if  guess_num<num:
                print("你猜小了。")

print(f"你总共猜了{count}次")
```

###  while循环的嵌套应用

程序中的循环

while条件1：

​    条件1满足时，做的事情1

​    条件1满足时，做的事情2

​    条件1满足时，做的事情3......

​    while条件2：

​        条件2满足时，做的事情1

​        条件2满足时，做的事情2

​        条件2满足时，做的事情3......

```python
i=1
while i <=100:
    print(f"今天是第{i}天，准备......")
    j=1
    while j<=10:
        print(f"送给小美第{j}只玫瑰花")
        j += 1
    print("小美，你好。")
    i += 1
print(f"坚持到第{i-1}天，说你好。")
```

其基于空格缩进来决定层次关系的。

### while循环的嵌套案例

在即将完成的案例中，我们需要使用print语句，输出不换行的功能。

```python
print("Hello",end='')
print("World",end='')
```

制表符

在标齐时可如下：

```python
print("Hello\tWorld")
print("itheima\tbest")
```

### 九九乘法表

```python
i=1
while i<=9 :

    j=1
    while j<=i:
        print(f"{i}*{j}={j*i}\t",end='')
        j+=1
    i+=1
    print()   #print空内容就是输出一个换行。
```

### for循环的基础语法

for循环

除了while循环语句外，python同样提供了for循环语句。

两者能完成的功能基本差不多，但任有一些区别：

* while循环的循环功能条件是自定义的，自行控制循环条件。

* for循环是一种“轮询”机制，是对一批内容进行“逐个处理”。

  for循环就是将“代办事项”逐个完成的循环机制。

  程序中的for循环

  ```
  for临时变量in待处理数据：
      循环满足条件时执行的代码

```python
name="ni"
for x name:
    print(x)
#输出结果：
n
i
```

即for循环会将循环体内的x进行处理。

与while循环不同，for循环是无法被定义循环条件的。要注意，循环语句内需要有空格缩进。

只能从被处理的数据中依次取出内容进行处理。所以python中的for循环无法构建无限循环（被处理的数据集不可能无限大）。

```python
name="in=theima is a brand itcast"
count=0
for x in name:
    if x == "a":
        count+=1
print(f"被统计的字符串中有{count}个a。")
```

### range语句

for循环语句，本质上是遍历：序列类型。

尽管除字符串外，其他的序列类型目前没学习到但不妨碍我们通过学习range语句，获得一个简单的数字序列。

语法1：

```python
range(num)
```

获取一个从0开始，到num结束的数字序列（不含num）本身

如range（5）取得的数据是：{0，1，2，3，4}

语法2：

```python
range(num1,num2)
```

获取一个从num1开始，到num2结束的数字序列（不含num2本身）

如：range（5，10）取得的数据是（5，6，7，8，9）

语法3：

```python
range(num1,num2,step)
```

获得一个从num1开始，到num2结束的数学序列（不含num2本身）数字之间的步长，以step为准（step默认为1）

如，range(5，10，2)取得的数据是：[5，7，9]

语法1实例：

```python
for x in range(10):
    print(x)
```

语法2实例：

```python
for x in range(5,10):
    print(x)
```

语法3实例：

```python
for x in range(5,10,3):
    print(x)
```

注意：数字之间的间距一般默认为1，当有第三个数字时以第三个数字为间距。

实操：

```python
num=0
for x in range(1,100):
    if (x%2)==0:
        num+=1
print(f"1-100中有{num}个偶数。")
```

### 变量作用域

```python
for 临时变量 in待处理数据集：
    循环满足条件时执行的代码
```

临时变量在编程规范上，作用范围（作用域），只限定在for循环内部

如果在for循环外部访问临时变量：

* 实际上是可以访问到的。
* 在编程规范上是不允许的，不建议这么做。

当想要在for循环的外部去访问临时变量时，应该在for循环之前把临时变量先定义好。

```python
i=0
for i in range(6)
    print(i)
print(i)    
```

总结：

1. for循环中的临时变量，其作用域限定为：循环内。
2. 这种限定：

* 是编程规范的限定，而非强制限定。
* 不遵守也能正常运行，但是不建议这样做。
* 如需访问临时变量，可以预先在循环外定义它。

### for循环的嵌套应用

程序中的嵌套for循环：

```python
for 临时变量 in 待处理数据集（序列）：
    循环满足条件应做的事情1
    循环满足条件应做的事情2
    循环满足条件应做的事情n
    ...
    for 临时变量 in 待处理数据集（序列）：
        循环满足条件应做的事1
        循环满足条件应做的事情2
        循环满足条件应做的事情n
```

实例：

```python
i=0
for i in range(1,101):
    print(f"今天是喜欢yrq的第{i}天。")
    for j in range(1,11):
        print(f"送给yrq的第{j}朵玫瑰花。")
    print("喜欢你yrq")
print(f"第{i}天，求婚成功！")
```

while和for循环相互嵌套使用：

```py
i=1
while i<=638:
    print(f"今天是喜欢yrq的第{i}天。")
    i+=1
    for j in range(1,11):
        print(f"送给yrq的第{j}朵玫瑰花。")
    print("喜欢你yrq")
print(f"第{i}天，求婚成功！")
```

```py
for循环或while循环：
    循环满足条件应做的事情1
    循环满足条件应做的事情2
    循环满足条件应做的事情n
    ...
    for循环或while循环：
        循环满足条件应做的事1
        循环满足条件应做的事情2
        循环满足条件应做的事情n
```

### 九九乘法表for循环版

```python
i=1
for i in range(1,10):
    j=i
    for j in range(1,i+1):
        print(f"{i}*{j}={j*i}\t",end='')
        j+=1
    i+=1
    print()

```

end=''表示不换行。

### 循环中断：break和continue

continue关键字作于：中断本次循环，直接进入下一次循环。

continue可以用于：for循环和while循环，效果一致。

```py
for i in range(1,100):
    语句1
    continue
    语句2
```

在代码中，遇到continue就结束当次循环，进行下一次。

所以语句2是不会执行的。

应用场景：

在循环中，因某些原因，临时结束本次循环。

```pyt
for i in range(1,10):
    print("语句1")
    continue
    print("语句2")
```

continue关键字只可以控制：它所在的循环临时中断。

```python
for i in range(1,10):
    print("语句1")
    for j in range(1,10):
        print("语句2")
        continue
        print("语句3")
    print("语句4")    
```

这时continue只会对内循环作用即输出为语句1，语句2，语句4.不会输出语句3.

```python
for i in range(1,10):
    print("语句1")
    for j in range(1,3):
        print("语句2")
        continue
        print("语句 3")
    print("语句4")
```

break关键字用于：直接结束循环。

break可以用于：for循环和while循环，效果一致。

```python
for i in range(1,200):
    语句1
    break
    语句2
语句3    
```

在循环内，遇到break就结束循环了。

所以，执行了语句1后，直接执行语句3了。

```python
for i in range(1,10):
    print("语句1")
    for j in range(1,3):
        print("语句2")
        break
        print("语句 3")
    print("语句4")
```

break关键字同样只可以控制：它所在的循环结束。

```python
for i in range(1,2):
    print("语句1")
    for j in range(1,2):
        print("语句2")
        break
        print("语句 3")
    print("语句4")

```

即停止一次循环输出后续循环会停止输出被破坏语句。

在嵌套循环中，只能作用在所在的循环上，无法对上层循环起作用。

实例：

```python
monry=10000
for i in range(1,21):
    import random
    score=random.randint(1,10)
    if score<5:
        print(f"员工{i}绩效分为{score},不满足条件，故不发放工资。")
        #continue跳过发放
        continue
    if monry>=1000:
        monry-=1000
        print(f"员工{i}绩效分为{score}，满足条件，可以发放工资。")
    else:
        print(f"余额不足，当前余额为{monry}元，请下个月再来。")
        #break结束发放
        break
```

自己做的案例：

```python
money=10000
for j in range(1,21):
    import random
    num=random.randint(1,10)
    if num<5:
        print(f"员工{j}你的绩效为{num}低于5分，不能领取工资")
        continue
    if money>=1000:
        #if num>=5:
        money-=1000
        print(f"员工{j}你的绩效为{num},发放工资1000元,账户余额为{money}元")
    else:
            print("工资发放完了，请下个月再领。")
            break
```

注意好先后顺序，以便于语句输出与后面程序的运行。

# python函数

函数：是组织好的，可重复 使用的，用来实现特定功能的代码段，提高代码的重复性，减少重复代码，提高开发效率。

```python
name="nihao"
length=len(name)
print(length)
```

因为，len（）是python内置的函数：

是提前写好的。

可以重复使用。

实现统计长度这一特定功能的代码段。

```python
str1="ni"
str2="hao"
str3="sky"
#定义一个计数的变量。
count=0
for i in str1:
    count+=1
print(f"字符串(str1)的长度是：{count}")
#可使用函数来优化这个过程。


def my_len(data):
    count=0
    for i in data:
        count+=1
    print(f"字符串{data}的长度是{count}")
my_len(str3)
my_len(str2)
my_len(str1)
```

注意好三个点：

1. 已组织好的。
2. 可重复使用的。
3. 针对特定功能。

## 函数的定义

函数的定义：

```python
def 函数名(传入参数)：
    函数体
    return 返回值
```

目前可用以下方法不讨论传入参数，和函数体。

```python
def say_hi():
    print("你好")
say_hi()
```

定义完函数之后需要去调用函数。

注意事项：

参数如不需要，就可以省略。

返回值如不需要，可以省略。

函数必须先定义后使用。

课后作业：

```pyt
def say_world():
    print("欢迎来到这个世界！")
    print("请出示您的健康码以及72小时核酸证明！")
say_world()
```

答案：

```python
def say_world():
    print("欢迎来到这个世界！\n请出示您的健康码以及72小时核酸证明")
say_world()
```

## 函数的参数

传入参数的功能：在函数进行计算的时候，接受外部(调用时)提供的数据。

```python
def add():
    result=1+2
    print(f"1+2的结果是:{result}")
```

上面的做法比较单一，可试一试下面的做法：

```python
def add (x,y):
    result=x+y
    print(f"{x}+{y}的结果是：{result}")
```

实现了每次计算的时x+y的值，可以在调用函数时来指定。

```python
def add(x,y,z):
    result=x+y*z
    print(f"最终结果是：{result}")
add(1,6,5)
```

* 函数定义中，提供的x和y，称之为：形式参数，表示函数声明将要使用2个参数。
* 参数之间使用逗号进行分隔。
* 函数调用中，提供的1，6，5，称之为：实际参数，表示函数执行时真正使用的参数值。
* 传入的时候，按照顺序传入数据，使用逗号分隔。

传入参数的数量是不受限制的。

* 可以不使用参数。
* 也可以仅使用任意N个参数。

注意事项：

* 函数定义中的参数，称之为形式参数。
* 函数调用中的参数，称之为实际参数。
* 函数的参数数量不限，使用逗号分隔开。
* 传入参数的时候，要和形式参数一一对应，逗号隔开。

课后作业：

```python
def tiwen(num):
    print("欢迎来到这里，请出示您的健康码及72小时核酸证明，并配合调查。")
    if num<=37.5:
        print(f"体温测量中，您的体温是：{num}度，体温正常，请进。")
    else:
        print(f"体温测量中，您的体温是：{num}度，需要隔离！")
tiwen(37.2)
```

## 函数的返回值

### 函数返回值的定义

程序中的返回值：

```python
def add(a,b):
    result=a+b
    return result
r=add(1,2)
print(r)
```

定义两数相加的函数功能。完成功能后，会将相加的结果返回给函数调用者，所以，变量r接收到了函数的执行结果。

综上所述：

所谓返回值，就是程序中函数完成事情后，最后给调用者的结果。

语法格式：

```python
def 函数(参数...):
    函数体
    return 返回值
变量=函数(参数)
```

注意：函数体在遇到return后就结束了，所以写在return后面的代码不会执行。

### None类型

None表示：空的，无实际意义的意思。

函数返回的None，就表示，这个函数没有返回什么有意义的内容。

也就是返回空的意思。

```python
def say_hi():
    print("你好呀!")
result=say_hi()
print(f"无返回值函数，返回的内容是：{result}")
print(f"无返回值函数，返回的内容类型是：{type(result)}")
```

其使用意义：

1. 用在函数无返回值上。
2. 用在if判断上。

* 在if判断中，None等同于False。
* 一般用于在函数中主动返回None，配合if判断做相关处理。

3. 用于声明无内容的变量上。

* 定义变量，但暂时不需要变量有具体值，可以用None来代替。

  ```python
  #暂不赋予变量具体值
  name=None
  ```

  

  ```py
  def check_age(age):
      if age>18:
          return None
      result=check_age(5)
      if not result:
          print("未成年，不可进入。")
  ```

  其使用场景：

  * 函数返回值。
  * if判断。
  * 变量定义。

## 函数说明文档

函数是纯代码语言，想要理解其含义，就需要一行行的去阅读理解代码，效率比较低。

我们可以给函数添加说明文档，辅助理解函数的作用。

语法如下：

```python
def func(x,y):
    """
    函数说明
    ：param x:形参x的说明
    ：param y:形参y的说明
    ：return:返回值的说明
    """
    函数体
    return 返回值
```

通过多行注释的形式，对函数进行说明解释。

* 内容应写在函数体之前。
* ：param用于解释参数。
* :return用于解释返回值。

## 函数的嵌套调用

所谓函数嵌套调用指的是一个函数里面又调用了另一个函数。

```py
#定义函数func_b
def func_b():
    print("---2---")
#定义函数func_a,并在内部调用func_b    
def func_a():
    print("---1---")
#嵌套调用func_b    
    func_b()
    print("---3---")
#请调用函数func_a
func_a()
"""输出结果：
---1---
---2---
---3---"""
```

执行顺序为：

首先被调动的函数a会先执行，之后函数b才会被执行，之后就是c被执行。

执行流程：函数a中执行到调用函数b的语句，会将函数b全部执行完成后，继续执行函数a的剩余内容。

## 变量的作用域

变量作用域指的是变量的作用范围（变量在哪里可用，在哪里不可用）主要分为两类：局部变量和全局变量。

所谓局部变量是定义在函数体内部的变量，即只在函数体内生效。

```py
def testA():
    num=100
    print(num)
    
testA()    #100
print(num)    #报错：name'num' is not defined
```

变量a是定义在"testA"函数内部的变量，在函数外部访问则立即报错。



局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。当函数体出来了，局部变量就无法使用了。



所谓全局变量，指的是在函数体内、外都能生效的变量。

```py
#定义全局变量a
num=100

def testA():
    print(num)    #访问全局变量num，并打印变量num存储的数据。

    
def testB():
    print(num)    #访问全局变量num，并打印变量num存储的数据。

testA()    #100
testB()    #100
    
```

### global关键字

```python
num=100

def testA():
    print(num)    #访问全局变量num，并打印变量num存储的数据。

    
def testB():
    #global关键字声明a是全局变量。
    global num    #设置内部变量为全局变量。
    num=200
    print(num)    #访问全局变量num，并打印变量num存储的数据。

testA()    #100
testB()    #100 
print(f'全局变量num={num}')    #结果：全局变量num=200
```

## 综合案例：

```python
money=5000000
name=None
###要求客户输入姓名。
name=input("请输入您的姓名：")
#定义查询函数
def query(show_header):
    print("-----查询余额-----")
    print(f"{name},您好，您的余额为：{money}元。")
#定义存款函数
def saving(num):
    global money#money在函数内部定义为全局变量
    money+=num
    print("-----存款-----")
    print(f"{name},您好，您存款{num}元成功。")
    #调用query函数查询余额
    query(False)
#定义取款函数
def get_money(num):

    global money#money在函数内部定义为全局变量
    money-=num
    print("-----取款-----")
    print(f"{name},您好，您取款{num}元成功。")
    #调用query函数查询余额
    query(False)
#定义主菜单函数
def main():
    print("-----主菜单-----")
    print(f"{name}您好，欢迎来到银行ATM，请选择您的操作：")
    print("查询金额\t\t[输入1]")
    print("存款\t\t[输入2]")
    print("取款\t\t[输入3]")
    print("退出\t\t[输入4]")
    return input("请输入您的选择：")
#设置无限循环，确保程序不退出
while True:
    keyboard_input=main()
    if keyboard_input=="1":
        query(True)
        continue    #通过continue继续下一次循环，一进来就是回到主菜单
    elif keyboard_input=="2":
        num=int(input("您想要存多少钱?请输入："))
        saving(num)
        continue
    elif keyboard_input=="3":
        num = int(input("您想要取多少钱?请输入："))
        get_money(num)
        continue
    else:
        print("程序退出！")
        break
```

# python数据容器

### 数据容器入门

python中的数据容器：

一种可以容纳多份数据的数据类型，容纳的每一份数据称之为一个元素每一个元素，可以是任意类型的数据，如字符串，数字，布尔等。

数据容器根据特点的不同，如：

* 是否支持重复元素。
* 是否可以更改。
* 是否有序，等。

分为五类，分别是：

列表（list），元组（tuple），字符串（str），集合（set），字典（dict）.

### 数据容器list(列表)

#### 列表的定义

```python
#字面量
[元素1，元素2，元素3...]

#定义变量
变量名称=[元素1，元素2，元素3...]

#定义空列表
变量名称=[]
变量名称=list()
```

列表内的每一个数据，称之为元素。

* 以[]作为标识。

* 列表内每一个元素之间用逗号隔开。 

  注意：列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套。

演示：

```python
my_list=[[1,2,3],[4,5,6]]
print(my_list)
print(type(my_list))
```

```py
my_list=[["nihao",678,True],[1,2,3,False]]
print(my_list)
```

#### 列表的下标引索

列表中的每一个元素，都有其位置下标索引，从前向后的方向，从0开始，依次递增，我们只需要按照下标索引，即可取得对应位置的元素，或者，可以反向索引，也就是从后向前：从-1开始，依次递减（-1，-2，-3，-4，......）。

```python
#语法：列表[下标索引]

name_list=["Tom","Lily","Rose"]
print(name_list[0])  #结果：TOM
print(name_list[1])  #结果：Lily
print(name_list[2])  #结果：Rose
```

```python
#语法：列表[下标索引]

name_list=["Tom","Lily","Rose"]
print(name_list[-3])  #结果：TOM
print(name_list[-2])  #结果：Lily
print(name_list[-1])  #结果：Rose
```

如果列表是嵌套的列表同样支持下标索引。

```py
name_list=[["Tom","Lily","Rose"],[1,2,3]]
print(name_list[0][0])  #结果：TOM
print(name_list[1][1])  #结果：2
print(name_list[0][2])  #结果：Rose
```

#### 列表的日常操作

| 列表append(元素)        | 向列表中追加一个元素                         |
| ----------------------- | -------------------------------------------- |
| 列表extend(容器)        | 将数据容器的内容依次取出，追加到列表尾部     |
| 列表.insert(下标，元素) | 在指定下标处，插入指定的元素                 |
| del列表[下标]           | 删除列表指定下标元素                         |
| 列表.pop(下标)          | 删除列表指定下标元素                         |
| 列表.remove(元素)       | 从前向后，删除此元素第一个匹配项             |
| 列表clear()             | 清空列表                                     |
| 列表.count(元素)        | 统计此元索在列表中出现的次数                 |
| 列表index(元素)         | 查找指定元素在列表的下标找不到报错ValueError |
| len(列表)               | 统计容器内有多少元本                         |

列表除了可以：

* 定义
* 使用下表索引获取值

以外，列表也提供了一系列功能：

* 插入元素

* 删除元素

* 清空列表

* 修改元素

* 统计元素个数

  等等功能，这些功能我们都称之为：列表的方法。

  函数是一个封装的代码单元，可以提供特定功能。

  在Python中，如果将函数定义为class（类）的成员，那么函数会称之为：方法。

函数：

```python
def add(x,y):
    return x+y
```

方法：

```python
class Student:
    
    
    def add(self,x,y):
        return x+y
```

方法和函数功能一样，有传入参数，有返回值，只是方法的使用格式不同：

函数使用：num=add(1,2)

方法的使用：

```python
student=Student()
num=student.add(1,2)
```

```python
mylist=["ni","hao","ya"]#查找某元素在列表内的下标索引。
index=mylist.index("ni")
print(f"ni在列表中的下表索引值是：{index}")
#如果被查找的元素不存在就会报错。 
```

语法：列表.index(元素)

##### 修改特定位置（索引）的元素值：

语法：列表[下标]=[值]

可以使用如上语法，直接对指定下标（正向，反向下标均可）的值进行：重新赋值（修改）。

```python
#正向下标
my_list=[1,2,3]
my_list[0]=5
print(my_list)    #结果：[5,2,1]

#反向下标
my_list=[1,2,3]
my_list[-3]=5
print(my_list)    #结果：[5,2,1]
```

列表的修改功能（方法）

##### 插入元素：

语法：列表。insert（下标，元素），在指定的下标位置插入指定的元素。

```python
my_list=[1,2,3]
my_list.insert(1,"nihao")
print(my_list)    #结果：[1,"nihao",2,3]
```

##### 追加元素：

语法：列表.append(元素)，将指定元素追加到列表的尾部。

```python
my_list=[1,2,3]
my_list.append(4)
print(my_list)    #结果为：[1，2，3，4]

my_list=[1,2,3]
my_list.append([4,5,6])
print(my_list)    #结果：[1,2,3,[4,5,6]]
```

追加元素方式2：

语法：列表.extend（其他数据容器），将其他数据的内容取出，一次追加到列表尾部。

```pyt
my_list=[1,2,3]
my_list.extend([4,5,6])
print(my_list)    #结果：[1,2,3,4,5,6]
```

##### 删除元素：

语法1：del列表[下标]

语法2：列表pop(下标)

```python
my_list=[1,2,3]

#方法1
del my_list[0]    #结果：[2,3]
#方法2
my_list.pop(0)
print(my_list)
```

其中pop不仅可以将列表中的元素删除还可以当返回值。

删除某元素在列表中的第一个匹配项。

语法：列表。remove（元素）

```python
my_list=[1,2,3,4,2]
my_list.remove(2)
print(my_list)    #结果：[1,3,4,2]
```

会将第一个出现的目标元素删除只能删除一次，如需在使用需要再次调动。

##### 清空列表内容，语法：列表。clear（）

```py
my_list=[1,2,3,4,2]
my_list.clear()
print(my_list)    #结果：[] 
```

##### 统计某元素在列表内的数量

语法：列表.coun(元素)

```py
my_list=[1,2,3,4,2]
print(my_list.coun(2))    #结果：2 
```

列表的特点：

* 可以容纳不同类型的元素（上限为2**63-1）.
* 可以容纳不同类型的元素（混装）。
* 数据是有序储存的（有下标序号）。
* 允许重复数据存在。
* 可以修改（增加或删除元素）。

### 练习

```python
age=[21,25,21,23,22,20]
age.append(31)
age.extend([29,33,30])
print(age)
print(age[0])
print(age[-1])
print(age.index(31))
```

### list(列表)的遍历

#### while循环

控制方法：

* 定义一个变量表示下标，从0开始。

* 循环条件为下标值<列表的元素数量。

  ```python
  index=0
  while index<len(列表):
      元素=列表[index]
      对元素进行处理
      index+=1
  ```

  实例：

  ```python
  my_list=["年轻","有钱","帅"]
  #循环控制变量通过下标索引来控制。默认为0
  #每一次循环将下标索引变量加1
  #循环条件：下标索引变量<列表的元素数量
  #定义一个变量用来标记列表的下标
  index=0    #初始值为0
  while index<len(my_list):
      #通过index变量取出对应下标的元素
      element=my_list[index]
      print(f"列表的元素：{element}")
      #至关重要 将循环变量(index)每一次循环都加1
      index+=1
  ```

  for循环

语法：

```py
for 临时变量 in 数据容器:
    对临时变量进行处理
```

表示，从容器内，依次取出元素并赋值到临时变量上。

在每一次的循环中，我们可以对临时变量(元素)进行处理。

```python
def list_for_func():
    my_list=[1,2,3,4,5]
    for element in my_list:
        print(f"列表的元素有：{element}")
list_for_func()
```

对比while与for循环的不同：

* 在循环控制上：

1. while循环可以自定义循环条件，并自行控制。

2. for循环不可以自定义循环条件，只可以一个个从容器内取出数据

* 在无限循环上：
  1. while循环可以通过条件控制做到无限循环。
  2. for循环理论上不可以，因为被遍历的容器容量不是无限的。

* 在使用场景上：

1. while循环适用于任何想要循环的场景。
2. for循环适用于，遍历数据容器的场景或简单的固定次数循环场景

实操：

```python
# while循环作业
my_list = [1,2,3,4,5,6,7,8,9,10]
num_list = []
index = 0
while index < len(my_list):
    element = my_list[index]
    if element %2== 0:
        print(element)
        num_list.append(element)
    index += 1
print(num_list)
# for循环作业


my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
num_list = []
for element in my_list:
    if element % 2 == 0:
        print(element)
        num_list.append(element)
print(num_list)
```

### 元组

元组同列表一样，都可以封装多个，不同类型的元素在内。但最大的不同点在于：元组一旦定义完成，就不可修改。

所以，当我们需要在程序内封装数据，又不希望封装的数据被篡改，那么元组就非常合适了。

元组的定义：定义元组使用小括号，且使用逗号隔开各个数据，数据可以是不同类型的数据。

```py
#定义元组字面量
(元素，元素，元素......，元素)
#定义元组变量
变量名称=()    #方式1
变量名称=tuple()    #方式2
```

```python
t1=(1,2,3,"ni","hao")
t2=()
t3=tuple()

print(f"t1的类型是：{type(t1)},类容是：{t1}")
print(f"t2的类型是：{type(t2)},类容是：{t2}")
print(f"t3的类型是：{type(t3)},类容是：{t3}")
```

注意事项：

```python
#定义3个元素的元组
t1=(1,"nihao",True)

#定义1个元素的元组
t2=("nihao",)    #注意，必须带有逗号，否则不是元组类型。
```

注意：元组只有一个数据，这个数据后面要添加逗号。

```py
t=(2)
print(f"t3的类型是：{type(t)},类容是：{t}")  #结果：t3的类型是：<class 'int'>,类容是：2
```

```py
t=(2,)
print(f"t3的类型是：{type(t)},类容是：{t}")    #结果：t3的类型是：<class 'tuple'>,类容是：(2,)
```

当然，元组也可以嵌套使用：

```py
t=((2,2,3),(4,5,6))

print(f"t3的类型是：{type(t)},类容是：{t}")
```

元组也可以通过下标索引来取出内容：

```py
t=((2,2,3),(4,5,6))

print(f"t3的类型是：{type(t)},类容是：{t}")
num=t[0][2]
print(num)
#从num中取出的数据为：3
```

元组的相关操作：

| 编号 | 方法    | 作用                                               |
| ---- | ------- | -------------------------------------------------- |
| 1    | index() | 查找某个数据，如果数据存在则返回其下标，否则报错。 |
| 2    | count() | 统计某个数据在当前元组出现的次数。                 |
| 3    | len()   | 统计元组内的元组个数。                             |

```python
#根据下标(索引)取出数据
t1=(1,2,"nihao")
print(t1[2])    #结果："nihao"
#根据index().查找特定元素的第一个匹配项
t1=(1,2,"nihao",3,4,"tinghaode")
print(t1.index("nihao"))    #结果：2
#统计元组内的元素个数
t1=(1,2,3)
print(len(t1))    #结果：3
```

注意，因为元组不可修改，所以局限性特别大。

```py
t=("nihao","shijie","wuyiqing",1,1,1,2,3,4,)
print(t.count(1))
#结果：3
```

元组的遍历：while

```python
t=("nihao","shijie","wuyiqing",1,1,1,2,3,4,)
index=0
while index<len(t):
    print(f"其含有的元素有：{t[index]}")
    index+=1
```

元组的遍历：for

```py
t=("nihao","shijie","wuyiqing",1,1,1,2,3,4,)
index=0
for x in t:
    print(f"其含有的元素有：{t}")
```

可以修改元组内的；list的内容（修改元素，增加，删减）

```python
t=("nihao","shijie","wuyiqing",1,1,1,2,3,4,[2,4,"nihao"])
index=0
t[-1][2]="x"
print(t)    #修改后的结果：('nihao', 'shijie', 'wuyiqing', 1, 1, 1, 2, 3, 4, [2, 4, 'x'])
```

#### 练习

```python
jie_lun=('周杰伦',11,["football","music"])
name=jie_lun[0]
age=jie_lun[1]

print(f"姓名为：{name}")
print(f"年龄为：{age}")
jie_lun[-1].remove("football")
jie_lun[-1].append("coding")
print(f'修改后的内容为：{jie_lun}')
```

### 数据容器：str（字符串）

字符串也是数据容器的一员。

字符串是字符的容器，一个字符串可以存放任意数量的字符串。

和其他容器如：列表，元组一样，字符串也可以通过下标进行访问。

* 从前向后，下标从0开始。
* 从后往前，下标从-1开始。

```py
# 通过下标获得特定位置字符。
name="nihao"
print(name[0])    #结果：n
print(name[-1])    #结果：o
```

同元组一样，字符串是一个：无法修改的数据容器。

#### 字符串的常用操作

##### 查找特定字符串的下标索引值。

语法：

```py
my_str="I am LiHua"
print(my_str.index("am"))   #结果：2
```

##### 字符串的替换

语法：字符串.replace(字符串1，字符串2)

功能：将字符串内的全部：字符串1，替换成字符串2.

注意：不是修改字符串本身，而是得到了一个新字符串。

```py
my_str="I am LiHua"
print(my_str.index("am"))
new_my_str=my_str.replace("LiHua","xiaohei")
print(new_my_str)    #结果为：I am xiaohei
```

##### 字符串的分割

语法：字符串.sp;it(分隔符字符串)

功能：按照指定的分隔符字符串，将字符串分为多个字符串，并存入列表对象中。

注意：字符串本身不变，而是得到了一个列表对象。

```py
my_str="I am LiHua"
print(my_str.index("am"))
new_my_str=my_str.split(" ")
print(new_my_str)
```

##### 字符串的规整操作（去前后空格）

语法：字符串.strip()

```py
my_str="  ni hao  "
print(my_str.strip())    #结果为："ni hao"
```

##### 字符串的规整操作（去前后指定字符串）

语法：字符串.strip(字符串)

```py
my_str="12ni hao  "
print(my_str.strip("12"))    #结果为："ni hao"
```

| 编号 | 操作                                   | 说明                                                         |
| ---- | -------------------------------------- | ------------------------------------------------------------ |
| 1    | 字符串[下标]                           | 根据下标索引取出特定位置字符                                 |
| 2    | 字符串.index(字符串)                   | 查找给定字符的第一个匹配项的下标                             |
| 3    | 字符串.replace(字符串1,字符串2)        | 将字符串内的全部字符串1，替换为字符串2.不会修改原字符串，而是得到一个新的按照给定字符串. |
| 4    | 字符串.split(字符串)                   | 按照给定字符串，对字符串进行分隔不会修改原字符串，而是得到个新的列表 |
| 5    | 字符串.strip()    字符串.strip(字符串) | 移除首尾的空格和换行符或指定字符串                           |
| 6    | 字符串.count(字符串)                   | 统计字符串内某字符串的出现次数                               |
| 7    | len(字符串)                            | 统计字符串的字符个数                                         |

作为数据容器，字符串有如下几个特点：

只可以存储字符串。

长度任意（取决与内存大小）。

支持下标引索。

允许重复字符存在。

不可以修改（增加或删除元素等）。

支持for循环以及while循环。

##### 练习

```py
#定义变量
text="itheima itcast boxuegu"
#统计有多少个it，结果为：2.
print(text.count("it"))
#将字符串内的空格全部替换为“|”
new_text=text.replace(" ","|")
#得到替换后的结果。
print(f"修改后的：{new_text}")
#并按照"|"进行字符串的分割，得到列表。结果为：修改后的：itheima|itcast|boxuegu
print(new_text.split("|"))
#结果为：['itheima', 'itcast', 'boxuegu']
```

#### 数据容器的切片

序列：是指内容连续，有序，可使用下标索引的一类数据容器，

列表，元组，字符串，均可视为序列。

##### 序列的常用操作—切片

序列支持切片，即：列表，元组，字符串，均支持进行切片操作。

切片：从一个序列中，取出一个子序列。

语法：序列[起始下标：结束下标：步长]

表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新的序列：

* 起始下标表示从何处开始，可以留空，留空视作从头开始。
* 结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾。
* 步长表示，依次取出元素的间隔。
* 步长1表示，一个个取元素。
* 步长2表示，每次跳过1个元素取。
* 步长N表示，每次跳过N-1个元素。
* 步长为负数表示，反向取(注意，起始下标和结束下标也要反向标记)。

切片：

```py
[1,2,3,4,5]中取出部分元素，即形成子序列如：[2，3，4]
```

注意：此操作不会影响序列本身，而是会得到一个新的序列（列表，元组，字符串）。

```py
#对list进行切片，从1开始，4结束，步长1
my_list=[0,1,2,3,4,5,6]
result1=my_list[1:4]  #步长默认为1，所以可以省略不写。
print(f"结果1：{result1}")#结果1：[1, 2, 3]

#对tuple进行切片，从头开始，到最后结束，步长1
my_tuple=(0,1,2,3,4,5,6)
result2=my_tuple[:]    #起始和结束不写表示从头到尾，步长为1可以省略。
print(f"结果：{result2}")#结果：(0, 1, 2, 3, 4, 5, 6)


#对str进行切片，从头开始，到最后结束，步长为2
my_str="0123456"
result3=my_str[::2]
print(f"结果为：{result3}")#结果为：0246


#对str进行切片，从头开始，最后结束，步长-1
my_str="01234567"
result4=my_str[::-1]
print(f"结果为：{result4}")#结果为：76543210


#对列表进行切片，从3开始，到1结束，步长-1
my_list=[0,1,2,3,4,5,6]
result5=my_list[3:1:-1]
print(f"结果为：{result5}")#结果为：[3, 2]


#对元组进行切片，从头开始，到尾结束，步长-2
my_tuple=(0,1,2,3,4,5,6)
result6=my_tuple[::-2]
print(f"结果为：{result6}")#结果为：(6, 4, 2, 0)
```

练习：

```py
my_str1="万过薪月，员序程马黑来，nohtyP学"
#倒序字符串，切片取出
n=my_str1[::-1][9:14]
print(f"方法1的结果：{n}")
#切片取出，然后倒序
n2=my_str1[5:10][::-1]
print(f"方法2的结果：{n2}")

#split分隔","replace替换“来”为空，倒序字符串
my_str2= "万过薪月，员序程马黑来，nohtyP学"
n3=my_str2.split("，")[1].replace("来", "")[::-1]
print(f"方法3的结果：{n3}")
方法1的结果：黑马程序员
方法2的结果：黑马程序员
方法3的结果：黑马程序员
```

#### set（集合）

集合最主要的特点就是：不支持重复元素（相当于自带去重功能），并且内容无序。

基本语法：

```py
#定义集合字面量
{元素，元素，......，元素}
#定义集合变量
变量名称={元素，元素，......，元素}
#定义空集合
变量名称=set()
```

集合使用的符号为"{}"

```py
#定义集合
my_set={1,2,3,4,5,5,4,3,"nihao","你好","，""li"}
new_my_set=set()
print(f"my_sset的内容是：{my_set},类型是{type(my_set)}")
print(f"new_my_set的内容是：{new_my_set},类型是{type(new_my_set)}")
my_sset的内容是：{1, 2, 3, 4, 5, 'nihao', '，li', '你好'},类型是<class 'set'>
new_my_set的内容是：set(),类型是<class 'set'>
```

可以看出集合是无序的不可重复的。

因为集合是无序的，所以集合不支持：下标索引访问。但是支持修改。

##### 添加新元素

语法：集合.add(元素)。将指定元素，添加到集合内。

结果：集合本身被修改，添加了新元素。

```py
my_set={"Hellow","world"}
my_set.add("nihao")
print(my_set)    #结果{'nihao', 'world', 'Hellow'}
```

当添加的元素为重复元素时，是不会被添加进去的。

##### 移除元素

语法：集合.remoove(元素)，将指定元素从集合内移除。

结果：集合本身被修改，移除了元素。

```py
my_set={"Hellow","nihao","world"}
my_set.remove("nihao")
print(my_set)    #结果{'Hellow', 'world'}
```

##### 从集合中随机取出元素

语法：集合.pop(),功能，从集合中随机取出一个元素。

结果：会得到一个元素的结果。同时集合本身被修改，元素被移除。

```py
#随机取出一个元素
my_set={"Hellow","nihao","world"}
e=my_set.pop()
print(my_set)
print(e)  #结果：{'Hellow', 'nihao'}
               #结果：world
```

##### 清空集合

```py
my_set={'Hellow', 'nihao'}
my_set.clear()
print(my_set)  #结果为：set()
```

##### 取出2个集合的差集

语法：集合1.difference(集合2)，功能：取出集合1和集合2的差集（集合1有而集合2没有的）。

结果：得到一个新的集合，集合1和集合2不变。

```py 
set1={1,2,3}
set2={1,5,6}
#取出差集
set3=set1.difference(set2)
print(set3)   #结果：{2, 3}
print(set1)   #结果：{1, 2, 3} 不变
print(set2)   #结果：{1, 5, 6} 不变
```

##### 消除2个集合的差集

语法：集合1.difference_update(集合2)

功能：对比集合1和集合2，在集合1内，删除和集合2相同的元素。

结果：集合1被修改，集合2不变。

```py
set1={1,2,3}
set2={1,5,6}
#取出差集
set3=set1.difference_update(set2)
print(set1)   #结果：{2, 3}
print(set2)   #结果：{1, 5, 6}
```

##### 2个集合合并

语法：集合1.union(集合2)

功能：将集合1和集合2组合成新集合。

结果：得到新集合，集合1和集合2不变。

```py
set1={1,2,3}
set2={1,5,6}
#取出合并集合
set3=set1.union(set2)
print(set1)   #结果：{1, 2, 3}
print(set2)   #结果：{1, 5, 6}
print(set3)   #结果：{1, 2, 3, 5, 6}
```

##### 统计集合元素数量

```py
set1={1,2,3}
num=len(set1)
#取出集合数量
print(num)   #结果：3
```

注意，由于会去重所以重复的不会重复算入。

##### 集合的遍历

注意，集合不支持下标索引，不能使用while循环，但是可以使用for循环。

```py
set1={1,2,3,4,4,3}
for i in set1:
    print(i)
#结果：
1
2
3
4
```

集合常用功能总结：

| 编号 | 操作                           | 说明                                                         |
| ---- | ------------------------------ | ------------------------------------------------------------ |
| 1    | 集合.add(元素)                 | 集合内添加一个元素。                                         |
| 2    | 集合.remove(元素)              | 移除集合内指定的元素。                                       |
| 3    | 集合.pop()                     | 从集合中随机取出一个集合。                                   |
| 4    | 集合.clear()                   | 将集合清空。                                                 |
| 5    | 集合1.difference(集合2)        | 得到一个新集合，内含2个集合的差集，原有的2个集合内容不变。   |
| 6    | 集合1.difference_update(集合2) | 在集合1中，删除集合2中存在的元素，集合1被修改，集合2不变。   |
| 7    | 集合1.union(集合2)             | 得到1个新集合，内含2个集合的全部元素，原有的2个集合内容不变。 |
| 8    | len(集合)                      | 得到一个整数，记录了集合的元素数量。                         |

* 可以容纳多个数据。
* 可以容纳不同类型的数据。（混装）
* 数据是无序存储的（不支持下标索引）
* 不允许重复数据存在。
* 可以修改（增加或删除元素等）。
* 支持for循环。

#### 课后练习：

```py
my_list=["黑马程序员","传智播客","黑马程序员","itheima","itcast","itheima","itcast","best"]
#定义一个空集合
my_set=set()
#通过for循环遍历列表
for x in my_list:
    #在for循环中将列表的元素添加至集合
    my_set.add(x)
#最终得到元素去重后的集合对象，并打印输出    
print(my_list)
print(my_set)
#结果1：['黑马程序员', '传智播客', '黑马程序员', 'itheima', 'itcast', 'itheima', 'itcast', 'best']
#结果2：{'传智播客', 'itcast', '黑马程序员', 'itheima', 'best'}
```

### 数据容器：dict（字典，映射）

#### 字典的定义

通过字典，可以实现key取出valuede操作。

字典的定义，同样使用{}，不过存储的元素是一个个的：键值对，如下语法：

```py
#定义字典字面量
{key:value,key:value,......,key:value}
#定义字典变量
my_dict={key:value,key:value,......,key:value}
#定义空字典
my_dict={}    #空字典定义方式1
my_dict=dict()    #空字典定义方式2
```

效果：

```py
#定义字典
my_dict={"王力洪":67,"小红":78,"小兰":77}
#定义空字典
my_dict2={}
my_dict3=dict()
print(f"字典1的内容是：{my_dict},类型：{type(my_dict)}")
print(f"字典2的内容是：{my_dict2},类型：{type(my_dict2)}")
print(f"字典3的内容是：{my_dict3},类型：{type(my_dict3)}")
'''字典1的内容是：{'王力洪': 67, '小红': 78, '小兰': 77},类型：<class 'dict'>
字典2的内容是：{},类型：<class 'dict'>
字典3的内容是：{},类型：<class 'dict'>'''
```

字典同集合一样，不可以使用下标索引，但字典可以通过key值来取得相对应的value。

```py 
my_dict={"王力洪":67,"小红":78,"小兰":77}
print(my_dict["王力洪"])   #结果是：67
print(my_dict["小红"])   #结果是：78
print(my_dict["小兰"])   #结果是：77
```

字典的嵌套：

字典的key可以是任意数据类型（key不可为字典）。

那么就说明字典是可以嵌套的。

```py
stu_score_dict={
    "王力洪":{
        "语文":77,
        "数学":69,
        "英语":67
    },"周杰论":{
        "语文": 64,
        "数学": 49,
        "英语": 88
    },"林俊洁":{
        "语文": 79,
        "数学": 64,
        "英语": 64
    }
}
print(f"学生信息：{stu_score_dict}")
#从嵌套中获取数据
core=stu_score_dict["周杰论"]["语文"]
print(f"周杰论的信息：{core}")
#结果1：学生信息：{'王力洪': {'语文': 77, '数学': 69, '英语': 67}, '周杰论': {'语文': 64, '数学': 49, '英语': 88}, '林俊洁': {'语文': 79, '数学': 64, '英语': 64}}
#结果2：周杰论的信息：64

```

字典的注意事项：

* 键值对的key和Value可以是任意类型（key不可为字典）。
* 字典内key不允许重复，重复添加等同于覆盖原有数据。
* 字典是不可以使用下标索引的，而是通过key检索Value。

#### 字典的常用常用操作

* 新增元素：

语法：字典[key]=Value，结果：字典被修改，新增了元素。

```py
my_dict={"王力洪":67,"小红":78,"小兰":77}
#新增张学有的成绩
my_dict["张学有"]=86
print(my_dict)   #结果：{'王力洪': 67, '小红': 78, '小兰': 77, '张学有': 86}
```

* 更新元素：

语法：字典[Key]=Value，结果：字典被修改，元素被更新。

注意：字典key不可以重复，所以对已经存在的key执行上述操作，就是更新Value值。

```py
my_dict={"王力洪":67,"小红":78,"小兰":77}
#更改小红的考试成绩
my_dict["小红"]=88
print(my_dict)    #结果：{'王力洪': 67, '小红': 88, '小兰': 77}
```

* 删除元素

语法：字典.pop(key),结果：获得指定key的Value，同时字典被修改，指定key的数据被删除。

```py
my_dict={"王力洪":67,"小红":78,"小兰":77}
value=my_dict.pop("王力洪")
print(value)    #结果：67
print(my_dict)   #结果：{'小红': 78, '小兰': 77}
```

* 清空元素

```py
my_dict={"王力洪":67,"小红":78,"小兰":77}
my_dict.clear()
print(my_dict)    #结果为：{}
```

* 获取全部的key

语法：字典.keys() 结果：得到字典中的全部key

```py
my_dict={"王力洪":67,"小红":78,"小兰":77}
keys=my_dict.keys()
print(keys)    #结果：dict_keys(['王力洪', '小红', '小兰'])
```

* 遍历字典

```py
#方式1
my_dict={"王力洪":67,"小红":78,"小兰":77}
keys=my_dict.keys()
for key in keys:
    print(f"字典的key是：{key}")
    print(f"字典的value是：{my_dict[key]}")
#结果1：字典的key是：王力洪
#字典的value是：67
#字典的key是：小红
#字典的value是：78
#字典的key是：小兰
#字典的value是：77
```

```py
#方式2直接对字典进行for循环，每一次循环都是直接得到key
my_dict={"王力洪":67,"小红":78,"小兰":77}
for key in my_dict:
    print(f"字典的key是：{key}")
    print(f"字典的value是：{my_dict[key]}")
    #结果：字典的key是：王力洪
#字典的value是：67
#字典的key是：小红
#字典的value是：78
#字典的key是：小兰
#字典的value是：77
```



* 统计字典内的元素数量量

```py
my_dict={"王力洪":67,"小红":78,"小兰":77}
num=len(my_dict)
print(f"字典中的元素数量：{num}")
#结果是：字典中的元素数量：3
```

| 编号 | 操作             | 说明                                                 |
| ---- | ---------------- | ---------------------------------------------------- |
| 1    | 字典[key]        | 获取指定key对应的value值。                           |
| 2    | 字典.[key]=value | 添加或更新键值对。                                   |
| 3    | 字典.pop(key)    | 取出key对应的value并在字典中删除 此key对应的键值对。 |
| 4    | 字典.clear()     | 清空字典。                                           |
| 5    | 字典.keys()      | 获取字典的全部key，可用于for循环遍历字典。           |
| 6    | len(字典)        | 计算字典内的元素数量。                               |

总结：

* 可以容纳多个数据。
* 可以通过不同类型的数据。
* 每一份数据是keyvalue键值对。
* 可以通过key获取到valve，key不可重复（重复会覆盖）。
* 不支持下标索引。
* 可以修改。
* 支持foe循环，不支持while循环。

#### 课后作业

```py
#先定义一个字典
information={"王力宏":{"部门":"科技部","工资":3000,"级别":1},
            "周杰伦":{"部门":"市场部","工资":5000,"级别":2},
            "林俊杰":{"部门":"市场部","工资":7000,"级别":3},
            "张学友":{"部门":"科技部","工资":4000,"级别":1},
            "刘德华":{"部门":"市场部","工资":6000,"级别":2}
            }
#输出元字典的内容
print(f"升职加薪之前的结果：{information}")
#通过for循环遍历字典
for z in information:
    #判断级别，当级别为1时符合要求
    if information[z]["级别"]==1:
        #升职加薪
        #获取到员工的信息
        x=information[z]
        #修改员工的信息
        x["级别"]=2#级别加1
        x["工资"]+=1000#工资加1000
        #将员工的信息更新到information
        information[z]=x
升职加薪之前的结果：{'王力宏': {'部门': '科技部', '工资': 3000, '级别': 1}, '周杰伦': {'部门': '市场部', '工资': 5000, '级别': 2}, '林俊杰': {'部门': '市场部', '工资': 7000, '级别': 3}, '张学友': {'部门': '科技部', '工资': 4000, '级别': 1}, '刘德华': {'部门': '市场部', '工资': 6000, '级别': 2}}
对员工进行升职加薪后的结果：{'王力宏': {'部门': '科技部', '工资': 4000, '级别': 2}, '周杰伦': {'部门': '市场部', '工资': 5000, '级别': 2}, '林俊杰': {'部门': '市场部', '工资': 7000, '级别': 3}, '张学友': {'部门': '科技部', '工资': 5000, '级别': 2}, '刘德华': {'部门': '市场部', '工资': 6000, '级别': 2}}
```

### 数据容器对比总结

数据容器可以从以下视角进行简单的分类：

* 是否支持下标索引：

支持：列表，元组，字符串—序列类型

不支持：集合，字典—非序列类型

* 是否支持重复元素：

支持：列表，元组，字符串—序列类型

不支持：集合，字典—非序列类型

* 是否可修改：

支持：列表，集合，字典

不支持：元组，字符串

1. 基于各类数据容器的特点，他们的应用场景如下：

* 列表：一批数据，可修改，可重复的存储场景。
* 元组：一批数据，不可修改，可重复的存储场景。
* 字符串：一串字符串的存储场景。
* 集合：一批数据，去重存储场景。
* 字典：一批数据，可用key检索valve的存储场景。

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221015234318.png)

### 数据容器的通用操作

首先，在遍历上：

* 5类数据容器都支持for循环。
* 列表，元组，字符串支持while循环，集合，字典不支持（无法下标索引）

尽管遍历的形式各有不同，但是，他们都支持遍历操作。

len(容器)

统计容器的元素个数：

```py
my_list=[1,2,3]
my_tuple=(1,2,3,4,5)
my_str="nihao"
my_set={1,2,3,4,5}
my_dict={"key1":1,"key2":2,"key3":3,"key4":4,"key5":5}
print(len(my_list))#结果：3
print(len(my_tuple))#结果：5
print(len(my_str))#结果：5
print(len(my_set))#结果：5
print(len(my_dict))#结果：5
```

max（容器）

统计容器的最大值：

```py
my_list=[1,2,3]
my_tuple=(1,2,3,4,5)
my_str="nihao"
my_set={1,2,3,4,5}
my_dict={"key1":1,"key2":2,"key3":3,"key4":4,"key5":5}
print(max(my_list))#结果：3
print(max(my_tuple))#结果：5
print(max(my_str))#结果：o
print(max(my_set))#结果：5
print(max(my_dict))#结果：5
```

min（容器）

统计容器的最小值：

```py 
my_list=[1,2,3]
my_tuple=(1,2,3,4,5)
my_str="nihao"
my_set={1,2,3,4,5}
my_dict={"key1":1,"key2":2,"key3":3,"key4":4,"key5":5}
print(min(my_list))#结果：1
print(min(my_tuple))#结果：1
print(min(my_str))#结果：a
print(min(my_set))#结果：1
print(min(my_dict))#结果：key1
```

容器的通用转换功能：

除了下标索引这个共性外，还可以通过类型转换

list(容器)：将给定容器转为列表。

str(容器)：将给定容器转为字符串。

tuple（容器）：将给定容器转换为元组。

set（容器）：将给定容器转换为集合。

```py
my_list=[1,2,3]
my_tuple=(1,2,3,4,5)
my_str="nihao"
my_set={1,2,3,4,5}
my_dict={"key1":1,"key2":2,"key3":3,"key4":4,"key5":5}
print((f"列表转列表的结果是：{list(my_list)}"))
print((f"元组转列表的结果是：{list(my_tuple)}"))
print((f"字符串转列表的结果是：{list(my_str)}"))
print((f"集合转列表的结果是：{list(my_set)}"))
print((f"字典转列表的结果是：{list(my_dict)}"))
列表转列表的结果是：[1, 2, 3]
元组转列表的结果是：(1, 2, 3, 4, 5)
字符串转列表的结果是：nihao
集合转列表的结果是：{1, 2, 3, 4, 5}
字典转列表的结果是：{'key1': 1, 'key2': 2, 'key3': 3, 'key4': 4, 'key5': 5}
```

其他的转换类似.

当字典转化为元组和集合时其value值会丢失。



```py
my_dict={"key1":1,"key2":2,"key3":3,"key4":4,"key5":5}
print((f"字典转元组的结果是：{tuple(my_dict)}"))
字典转元组的结果是：('key1', 'key2', 'key3', 'key4', 'key5')
```

```py
my_dict={"key1":1,"key2":2,"key3":3,"key4":4,"key5":5}
print((f"字典转集合的结果是：{set(my_dict)}"))
字典转集合的结果是：{'key1', 'key4', 'key5', 'key3', 'key2'}
```



字典不能转换出来，因为它是需要键值对的，但它可以转换成字符串，内容不会丢失。



sorted(容器，[reverse=True])

将给定容器进行排序。 ![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221016213122.png)

```py
my_list=[1,5,4]
my_tuple=(0,5,2,4,1)
my_str="nihao"
my_set={1,2,4,5,2}
my_dict={"key1":1,"key2":2,"key5":3,"key3":4,"key4":5}
print((f"列表对应的排序结果是：{sorted(my_list)}"))
print((f"元组对应的排序结果是：{sorted(my_tuple)}"))
print((f"字符串对应的排序结果是：{sorted(my_str)}"))
print((f"集合对应的排序结果是：{sorted(my_set)}"))
print((f"字典对应的排序结果是：{sorted(my_dict)}"))
列表对应的排序结果是：[1, 4, 5]
元组对应的排序结果是：[0, 1, 2, 4, 5]
字符串对应的排序结果是：['a', 'h', 'i', 'n', 'o']
集合对应的排序结果是：[1, 2, 4, 5]
字典对应的排序结果是：['key1', 'key2', 'key3', 'key4', 'key5']
```

使用后结果会变成列表对象，

反向排序：

```py
my_list=[1,5,4]
my_tuple=(0,5,2,4,1)
my_str="nihao"
my_set={1,2,4,5,2}
my_dict={"key1":1,"key2":2,"key5":3,"key3":4,"key4":5}
print((f"列表对应的排序结果是：{sorted(my_list,reverse=True)}"))
print((f"元组对应的排序结果是：{sorted(my_tuple,reverse=True)}"))
print((f"字符串对应的排序结果是：{sorted(my_str,reverse=True)}"))
print((f"集合对应的排序结果是：{sorted(my_set,reverse=True)}"))
print((f"字典对应的排序结果是：{sorted(my_dict,reverse=True)}"))
列表对应的排序结果是：[5, 4, 1]
元组对应的排序结果是：[5, 4, 2, 1, 0]
字符串对应的排序结果是：['o', 'n', 'i', 'h', 'a']
集合对应的排序结果是：[5, 4, 2, 1]
字典对应的排序结果是：['key5', 'key4', 'key3', 'key2', 'key1']
```

### 拓展字符串大小比较

在程序中，字符串所用的所有字符，如：

* 大小写英文单词
* 数字
* 特殊符号（！，\、@等）

都有其对应的ASCII码表值。

每一个字符都能对应上一个：数字的码值。

字符串进行比较就是基于数字的码值大小进行比较的。

字符串是按位比较，也就是一位一位进行对比，只要有一位大，那么整体就大。

# Python函数进阶

### 函数多返回值

当一个函数有两个return时，只会执行第一个，后面的都不会执行了。

当想要返回多个返回值时可以如下操作：

```py
def test_retrun():
    return 1,2
x,y=test_retrun()
print(x)#结果：1
print(y)#结果：2
```

值与值之间通过逗号隔开，不受类型限制。

### 函数的多种传参方式

使用方式的不同，函数有4钟常见的使用方式：

* 位置参数
* 关键字参数
* 缺省参数
* 不定长参数

位置参数：调用函数时根据函数定义的参数位置来传递参数。

```py
def user_info(name,age,gender):
    print(f'您的名字是{name},年龄是{age}，性别是{gender}')
user_info('TOM',20,'男')    
```

注意：传递的参数和定义的参数的顺序及个数必须一致。

关键字参数：函数调用时通过“键=值”形式传递参数。

作用：可以让函数更加清晰，容易使用，同时也清除了参数的顺序要求。

```py
def user_info(name,age,gender):
    print(f"您的名字是{name},年龄是{age}，性别是{gender}")
    #关键字传参
user_info(name="小明",age=20,gender="男")    
#可以不按照固定顺序
user_info(age=20,gender="男",name="小明")
#可以和位置参数混用，位置参数必须在前面，且匹配参数顺序
user_info("小明",age=20,gender=“男)
```

注意：调用函数时，如果有位置参数时，位置参数必须在关键参数的前面，但关键参数之间不存在先后顺序。

缺省参数：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。

作用：当调用函数时没有传递参数，就会使用默认是用缺省参数对应的值。

```py
def user_info(name,age,gender="男"):
    print(f"您的名字是{name},年龄是{age}，性别是{gender}")


user_info("TOM",20)
user_info("ROSE",18,"女")
```

注意：

函数调用时，如果为缺省参数传值则修改默认参数值，否则使用这个默认值。设置默认值的时候需要将设置的默认值放在最后。

不定长参数：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景，

作用：当调用函数时不确定参数个数时，可使用不定长参数

不定长参数的类型：

1. 位置传递
2. 关键字传递

```py
def user_info(*args):
    print(args)


#("TOM",)
user_info("TOM",)
#('TOM',18)
user_info('TOM',18)
```

注意：传进的所有参数都会被args变量收集，他会根据传进参数的位置合并为一个元组（tuple），args是元组类型，这就是位置传递。

关键字传递

```py
def user_info(**kwargs):
    print(kwargs)

#{'name':'TOM','age':18,'id':110}    
user_info(name="TOM",age=18,id=110)    
```

注意：

参数是“键=值”形式的形式的情况下，所有的“键=值”都会被kwargs

接受，同时会根据“键=值”组成字典。

### 匿名函数

#### 函数作为参数传递

在这之前所学的都是接受数据作为参数传入。

其实我们所学的函数本身也可以作为参数传入另一个函数内。

```py
def test_func(compute):
    result=compute(1,2)
    print(result)

def compute(x,y):
    return x+y
test_func(compute)
#结果：3
```

函数compute，作为参数，传入了test_fun函数中使用。

* test_func需要一个函数作为参数传入，这个函数需要接收2个数字进行计算，计算逻辑由这个被传入函数决定。
* compute函数接收2个数字对其进行计算，compute函数作为参数，传递给了test_func函数使用。
* 最终，在test_func函数内部，由传入的compute函数，完成了对数字的计算操作。

所以，这是一种，==计算逻辑的传递，而非数据的传递。==

就像上述代码那样，不仅仅是相加，相减，相除，等任何逻辑都可以自行定义并作为函数传入。

==函数本身是可以作为参数，传入另一个函数中进行使用的。==

#### lambda匿名函数

函数的定义中：

* def关键字，可以定义带有名称的函数。
* lambda关键字，可以定义匿名函数（无名称）

有名称的函数，可以基于名称重复使用。

无名称的匿名函数，只可临时使用一次。

匿名函数定义语法：

lambda传入参数：函数体（一行代码）

* lambda是关键字，表示定义匿名函数。
* 传入参数表示匿名函数的形式参数，如：x，y表示接收2个形式参数。
* 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码。

如下图代码，我们可以：

* 通过def关键字，定义一个函数，并传入，如下：

```py
def test_func(compute):
    result=compute(1,2)
    print(result)

def compute(x,y):
    return x+y
test_func(compute)
#结果：3
```

* 也可以通过lambda关键字，传入一个一次性使用的lambda匿名函数。

```py
def test_func(compute):
    result=compute(1,2)
    print(result)

def compute(x,y):
    return x+y
test_func(lambda x,y:x+y)
#结果：3
```

使用def和使用lambda，定义的函数功能完全一致，只是lambda关键字定义的函数是匿名的，无法二次使用。

注意：

当需要使用多行代码时，不可用lambda匿名函数，应该用def定义带名函数。

# Python的文件操作

### 文件的编码

编码技术即：翻译的规则，记录了如何将内容翻译成二进制，以及如何将二进制翻译回可识别内容。

计算机中有许多可用编码：

* UTF-8

* GBK
* Big5
* 等

不同的编码，将内容翻译成二进制也是不同的。

由于编码有许多，所以要使用正确的编码，才能对文件进行正确的读写操作。

UTF-8是目前全球通用的编码格式，除非有特殊需求，否则一律以UTF-8格式进行文件编码即可。 

### 文件的读取

内存中存放的数据在计算机关机后就会消失。要长久保存数据就要使用硬盘，光盘，U盘等设备。为了便于数据的管理和检索，引入了“文件”的概念。

一篇文章，一段视频都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中的数据。一般来说，文件可分为文本文件，视频文件，音频文件，图像文件，可执行文件等多种类别。

open（）打开函数

在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下：

```py
open(name,mode,encoding)
```

name:是要打开的目标文件名的字符串（可以包含文件所在的具体路径）。

mode:设置打开文件的模式（访问模式）：只读，写入，追加等。

encoding:编码格式（推介使用utf-8）

示例代码：

```py
f=open("python.txt","r",encoding"UTF-8)
#encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定。
```

注意：此时的‘f’是‘open’函数的文件对象，对象是python中一种特殊的数据类型，拥有属性和方法，可以使用对象，属性或对象，方法对其进行访问。

mode常用的三种基础访问模式

| 模式 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| r    | 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。 |
| w    | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从头开始编辑，原有内容会被删除。如果该文件不存在，创建新文件。 |
| a    | 打开一个文件用于追加，如果该文件已存在，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |

读操作相关方法：

read（）方法：

```py
文件对象.read(num)
```

num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。

readlines（）方法：

readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。

```py
打开文件
f=open("""D:\测试.txt.txt""","r",encoding="UTF-8")
#读取文件-read()
print(f"读取10字节的结果：{f.read(10)}")
print(f"读取10字节的结果：{f.read()}")
#结果：读取10字节的结果：每天都是一样的，做着
#读取10字节的结果：一样的事。
```

在一个环境中调用两次时，后一个会接着上一个的后面的内容，所以需要注意！

```py
f=open("""D:\测试.txt.txt""","r",encoding="UTF-8")
#读取文件-readlins()
lines=f.readlines()  #读取文件的全部行，封装到列表中
print(f"lines对象的类型{type(lines)}")
print(f"lines对象的内容是：{lines}")
#结果：lines对象的类型<class 'list'>
#结果：lines对象的内容是：['每天都是一样的，做着一样的事。']
```

 readline（）方法：一次读取一行内容

```py
#打开文件
f=open("""D:\测试.txt.txt""","r",encoding="UTF-8")
content=f.readline()
print(f"第一行：{content}")
content=f.readline()
print(f"第二行：{content}")
#关闭文件
f.close()
#结果：第一行：每天都是一样的，做着一样的事。

#第二行：想要去做的事有很多，要做的很难，达到目的是一个问题。
```

readline是每一次调用只输出一行，可以多次调用，完成输出每一行内容的目的。

for循环读取文件执行：

```py
#打开文件
f=open("""D:\测试.txt.txt""","r",encoding="UTF-8")
for line in f:
    print(f"每一行输出的内容：{line}")
    #结果：每一行输出的内容：每天都是一样的，做着一样的事。

#每一行输出的内容：想要去做的事有很多，要做的很难，达到目的是一个问题。
#每一行输出的内容：看看风景，想想事情，那么就结束了。
#每一行输出的内容：你想看什么世界？
#每一行输出的内容：你想做什么事情？
#每一行输出的内容：你想做什么样的人？
```

close（）关闭文件对象：

```py
#打开文件
f=open("""D:\测试.txt.txt""","r",encoding="UTF-8")
#关闭文件
f.close()
```

最后通过close关闭文件对象，也就是关闭对文件的占用，如果不调用close，同时程序没有停止，那么这个文件将一直被python程序占用。

with open语法：

```py
with open("""D:\测试.txt.txt""","r",encoding="UTF-8") as f:
    for line in f :
        print(f"每一行的内容：{line}")
#结果：每一行的内容：每天都是一样的，做着一样的事。
#每一行的内容：想要去做的事有很多，要做的很难，达到目的是一个问题。
#每一行的内容：看看风景，想想事情，那么就结束了。
#每一行的内容：你想看什么世界？
#每一行的内容：你想做什么事情？
#每一行的内容：你想做什么样的人？
```

使用with open可以在执行完后面的操作之后自动结束程序运行，避免遗忘ciose用法。

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221027105641.png)

### 练习

```py
#打开文件，以读取模式打开
f=open("E:\word.txt.txt","r",encoding="UTF-8")
#方法一：读取全部内容，通过字符串count方法统计d的出现次数
countent=f.read()
count=countent.count("d")
print(f"'a'在文件中出现的次数{count}")
#结果：'a'在文件中出现的次数8
```

```py
#方法二：
f=open("E:\word.txt.txt","r",encoding="UTF-8")
count=0#使用count变量来累计”d“出现的次数
for line in f:
    line=line.strip() #去除开头和结尾的空格以及换行符
    word=line.split(" ")
    for words in word:
        if words=="d":
            count+=1
print(f"'a'在文件中出现的次数{count}")
f.close()
#结果：'a'在文件中出现的次数8
```

 

### 文件的写入

写操作快速入门

案例演示：

```py
#1.打开文件
f=open('E:\word.txt.txt','w')
#2.写入文件
f.write("helow world")
#3.内容刷新
f.flush()
f.close()
```

注意：

直接调用write，内容并未真正写入到文件，而是会积攒在程序的内存中，称之为缓冲区。

当调用flush的时候，内容会真正写入文件。

这样做是避免频繁的惭怍硬盘，导致效率下降（攒一堆，一次性写入磁盘）。

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221030131314.png)

close（）方法是自带flush（）方法的功能。

### 文件的追加

```py
#1.打开文件，通过a模式打开即可
f=open('E:\word.txt.txt','w')
#2.文件写入
f.write('nihao')
#3.内容刷新
f.flush()
```

注意：

a模式，文件不存在会创建文件。

a模式，文件存在会在最后追加写入文件。

![](C:\Users\李\Pictures\Saved Pictures\QQ图片20221030143910.jpg)

# Python异常，模块与包

### 了解异常

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221030211754.png)

### 异常的捕获方法

基本语法：

```py
try:
    可能发生错误的代码
except:
    如果出现错误的代码
```

快速入门：

需求：尝试以“r”模式打开文件，如果文件不存在，则以“w”方式打开。

```py
try:
    
    f=open("linux.txt",'r')
except:
    f=open("linux.txt","w")
```

  

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221031145729.png)

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221031145904.png)

### 异常的传递

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221031150224.png)

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221031150558.png)

### Python模块

#### 模块的导入

Python模块（Module），是一个Python文件，以.py结尾。模块能定义函数，类和变量，模块里也能包含可执行的代码

模块的作用：python中有很多各种不同的模块，每一个模块都可以帮助我们快速的实现一些功能。大白话：模块就是一个python文件，里面有类，函数，变量等，我们可以拿过来用（导入模块去使用）。

模块的导入方式：

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221031162804.png)

#### import模块名

基本语法：

```py
import模块名
import模块名1，模块名2

模块名.功能名（）
```

案例：导入time模块

```py
#导入时间模块
import time
print（"开始"）
#让程序睡眠2秒（阻塞）
print（"结束"）
```

*表示全部的意思，即模块内的所有内容都导入了。

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221031170140.png)

 

#### 自定义模块

##### 制作自定义模块

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221104223227.png)

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221104223540.png)

即新出现的会将原先的覆盖掉。

##### 测试模块

![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221104224315.png)



![](C:\Users\李\Pictures\Saved Pictures\QQ截图20221104224354.png)

但是可以手动直接导入。

### Python包

#### 自定义包
